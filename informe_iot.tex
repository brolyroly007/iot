% ============================================================================
% INFORME DE PROYECTO - INTERNET DE LAS COSAS
% Sistema de Detección de Caídas con ESP32 y MPU6050
% Universidad Nacional del Altiplano - Puno
% ============================================================================

\documentclass[12pt,a4paper]{article}

% ============================================================================
% PAQUETES
% ============================================================================
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-tabla]{babel}
\usepackage[left=2.54cm,right=2.54cm,top=2.54cm,bottom=2.54cm]{geometry}
\usepackage{setspace}
\usepackage{times}
\usepackage{graphicx}
\usepackage{float}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{url}
\usepackage[backend=biber,style=apa]{biblatex}
\usepackage{csquotes}

% ============================================================================
% CONFIGURACIÓN APA 7
% ============================================================================
\doublespacing
\setlength{\parindent}{1.27cm}
\setlength{\parskip}{0pt}

% Configuración de hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=blue
}

% Configuración de listings para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single
}
\lstset{style=mystyle}

% Configuración de títulos
\titleformat{\section}{\normalfont\bfseries\large}{\thesection.}{0.5em}{}
\titleformat{\subsection}{\normalfont\bfseries}{\thesubsection.}{0.5em}{}
\titleformat{\subsubsection}{\normalfont\bfseries\itshape}{\thesubsubsection.}{0.5em}{}

% ============================================================================
% INICIO DEL DOCUMENTO
% ============================================================================
\begin{document}

% ============================================================================
% PORTADA
% ============================================================================
\begin{titlepage}
    \centering
    \vspace*{1cm}

    {\Large\bfseries UNIVERSIDAD NACIONAL DEL ALTIPLANO}\\[0.3cm]
    {\large FACULTAD DE INGENIERÍA MECÁNICA ELÉCTRICA,}\\
    {\large ELECTRÓNICA Y SISTEMAS}\\[0.3cm]
    {\large ESCUELA PROFESIONAL DE INGENIERÍA DE SISTEMAS}\\[1.5cm]

    \rule{\textwidth}{1.5pt}\\[0.4cm]
    {\LARGE\bfseries SISTEMA IoT DE DETECCIÓN DE CAÍDAS}\\[0.2cm]
    {\LARGE\bfseries PARA ADULTOS MAYORES}\\[0.2cm]
    {\large\bfseries Implementación con ESP32-CAM, MPU6050 y Dashboard Web en Tiempo Real}\\[0.1cm]
    \rule{\textwidth}{1.5pt}\\[1.5cm]

    {\large\bfseries INFORME DE PROYECTO}\\[0.3cm]
    {\large Curso: Internet de las Cosas}\\[2cm]

    {\large\bfseries PRESENTADO POR:}\\[0.5cm]
    \begin{tabular}{ll}
        \textbf{Silver Rolando Rodriguez Luna} & Código: 181903 \\[0.3cm]
        \textbf{Yoel Brayan Apaza Llanos} & Código: 194879 \\
    \end{tabular}\\[2cm]

    {\large PUNO -- PERÚ}\\[0.3cm]
    {\large 2025}

\end{titlepage}

% ============================================================================
% ÍNDICE
% ============================================================================
\newpage
\tableofcontents
\newpage

% ============================================================================
% RESUMEN
% ============================================================================
\section*{Resumen}
\addcontentsline{toc}{section}{Resumen}

El presente proyecto desarrolla un sistema de Internet de las Cosas (IoT) para la detección automática de caídas en adultos mayores, utilizando un microcontrolador ESP32-CAM junto con un sensor acelerómetro/giroscopio MPU6050. El sistema implementa un algoritmo de detección basado en el análisis de la magnitud de aceleración, identificando patrones de caída libre seguidos de impacto. La información se transmite en tiempo real hacia un servidor desplegado en Vercel, donde una aplicación web desarrollada con Next.js 14 y React permite el monitoreo continuo del estado del dispositivo y el historial de eventos. La persistencia de datos se gestiona mediante Supabase como base de datos en la nube. Los resultados demuestran que el sistema detecta efectivamente caídas con umbrales configurables de 0.5G para caída libre y 2.5G para impacto, proporcionando una solución de bajo costo y alta disponibilidad para el cuidado de personas vulnerables.

\textbf{Palabras clave:} Internet de las Cosas, ESP32, MPU6050, detección de caídas, monitoreo remoto, adultos mayores, Next.js, Supabase.

% ============================================================================
% ABSTRACT
% ============================================================================
\section*{Abstract}
\addcontentsline{toc}{section}{Abstract}

This project develops an Internet of Things (IoT) system for automatic fall detection in elderly adults, using an ESP32-CAM microcontroller along with an MPU6050 accelerometer/gyroscope sensor. The system implements a detection algorithm based on acceleration magnitude analysis, identifying free-fall patterns followed by impact. Information is transmitted in real-time to a server deployed on Vercel, where a web application developed with Next.js 14 and React enables continuous monitoring of device status and event history. Data persistence is managed through Supabase as a cloud database. Results demonstrate that the system effectively detects falls with configurable thresholds of 0.5G for free fall and 2.5G for impact, providing a low-cost, high-availability solution for vulnerable people care.

\textbf{Keywords:} Internet of Things, ESP32, MPU6050, fall detection, remote monitoring, elderly, Next.js, Supabase.

\newpage

% ============================================================================
% 1. INTRODUCCIÓN
% ============================================================================
\section{Introducción}

\subsection{Planteamiento del Problema}

Las caídas representan una de las principales causas de lesiones y mortalidad en adultos mayores a nivel mundial. Según la Organización Mundial de la Salud (OMS), aproximadamente 684,000 personas fallecen cada año debido a caídas, siendo los mayores de 60 años quienes sufren el mayor número de caídas mortales. En el Perú, el envejecimiento poblacional ha incrementado la necesidad de sistemas de monitoreo y asistencia para este grupo vulnerable.

El problema principal radica en que muchos adultos mayores viven solos o pasan largos períodos sin supervisión directa. Una caída no detectada a tiempo puede resultar en complicaciones graves, incluyendo fracturas, traumatismos craneoencefálicos, y en casos extremos, la muerte por falta de atención médica oportuna.

\subsection{Justificación}

El desarrollo de sistemas IoT para detección de caídas se justifica por las siguientes razones:

\begin{itemize}[leftmargin=2cm]
    \item \textbf{Necesidad social:} El incremento de la población adulta mayor requiere soluciones tecnológicas accesibles para su cuidado.
    \item \textbf{Reducción de costos:} Los componentes utilizados (ESP32, MPU6050) son de bajo costo comparados con sistemas comerciales de monitoreo médico.
    \item \textbf{Accesibilidad tecnológica:} La disponibilidad de plataformas cloud gratuitas (Vercel, Supabase) permite implementar sistemas robustos sin inversión inicial significativa.
    \item \textbf{Escalabilidad:} El sistema puede expandirse para incluir múltiples dispositivos y usuarios.
\end{itemize}

\subsection{Objetivos}

\subsubsection{Objetivo General}

Diseñar e implementar un sistema IoT de detección de caídas utilizando ESP32-CAM y sensor MPU6050, con monitoreo en tiempo real mediante una aplicación web.

\subsubsection{Objetivos Específicos}

\begin{enumerate}[leftmargin=2cm]
    \item Implementar el hardware de adquisición de datos utilizando ESP32-CAM y sensor MPU6050.
    \item Desarrollar el firmware para la lectura de datos del acelerómetro y detección de patrones de caída.
    \item Crear una API RESTful para la recepción y almacenamiento de eventos de caída.
    \item Desarrollar un dashboard web para la visualización en tiempo real del estado del dispositivo y eventos registrados.
    \item Integrar el sistema con una base de datos en la nube para persistencia de datos.
    \item Realizar pruebas de funcionamiento y validación del sistema.
\end{enumerate}

\newpage

% ============================================================================
% 2. MARCO TEÓRICO
% ============================================================================
\section{Marco Teórico}

\subsection{Internet de las Cosas (IoT)}

El Internet de las Cosas se refiere a la interconexión de dispositivos físicos a través de Internet, permitiendo la recolección, transmisión y análisis de datos en tiempo real. Según Ashton (2009), quien acuñó el término, IoT representa la extensión del mundo digital al mundo físico mediante sensores y actuadores conectados.

Los sistemas IoT típicamente comprenden cuatro capas fundamentales:

\begin{enumerate}[leftmargin=2cm]
    \item \textbf{Capa de percepción:} Sensores y actuadores que interactúan con el mundo físico.
    \item \textbf{Capa de red:} Protocolos de comunicación (WiFi, Bluetooth, LoRa, etc.).
    \item \textbf{Capa de procesamiento:} Servidores y servicios cloud para el procesamiento de datos.
    \item \textbf{Capa de aplicación:} Interfaces de usuario y servicios finales.
\end{enumerate}

\subsection{Microcontrolador ESP32}

El ESP32 es un microcontrolador de bajo consumo desarrollado por Espressif Systems, que integra conectividad WiFi y Bluetooth. Sus características principales incluyen:

\begin{table}[H]
\centering
\caption{Especificaciones técnicas del ESP32}
\label{tab:esp32specs}
\begin{tabular}{ll}
\toprule
\textbf{Característica} & \textbf{Especificación} \\
\midrule
Procesador & Dual-core Xtensa LX6 \\
Frecuencia & Hasta 240 MHz \\
RAM & 520 KB SRAM \\
Flash & Hasta 16 MB \\
WiFi & 802.11 b/g/n \\
Bluetooth & v4.2 BR/EDR y BLE \\
GPIO & 34 pines programables \\
ADC & 18 canales de 12 bits \\
Interfaces & I2C, SPI, UART, I2S \\
Voltaje de operación & 3.3V \\
\bottomrule
\end{tabular}
\end{table}

La variante ESP32-CAM incluye adicionalmente una cámara OV2640 y ranura para tarjeta microSD, aunque para este proyecto se utiliza únicamente su capacidad de procesamiento y comunicación WiFi.

\subsection{Sensor MPU6050}

El MPU6050 es una unidad de medición inercial (IMU) de 6 ejes que combina un acelerómetro de 3 ejes y un giroscopio de 3 ejes. Este sensor utiliza la tecnología MEMS (Sistemas Microelectromecánicos) para medir aceleración y velocidad angular.

\begin{table}[H]
\centering
\caption{Especificaciones del sensor MPU6050}
\label{tab:mpu6050specs}
\begin{tabular}{ll}
\toprule
\textbf{Parámetro} & \textbf{Valor} \\
\midrule
Rango acelerómetro & $\pm$2g, $\pm$4g, $\pm$8g, $\pm$16g \\
Rango giroscopio & $\pm$250, $\pm$500, $\pm$1000, $\pm$2000 °/s \\
Resolución ADC & 16 bits \\
Interfaz & I2C (hasta 400 kHz) \\
Voltaje de operación & 2.375V -- 3.46V \\
Corriente en operación & 3.9 mA \\
Temperatura de operación & -40°C a +85°C \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Algoritmos de Detección de Caídas}

La detección de caídas mediante acelerómetros se basa en el análisis de patrones característicos que ocurren durante una caída humana. Según Bourke et al. (2007), una caída típica presenta las siguientes fases:

\begin{enumerate}[leftmargin=2cm]
    \item \textbf{Fase de caída libre:} Período donde la aceleración se aproxima a 0G debido a la ausencia de fuerzas de reacción.
    \item \textbf{Fase de impacto:} Momento de contacto con la superficie, caracterizado por picos de aceleración superiores a 2G.
    \item \textbf{Fase post-impacto:} Período de inmovilidad o movimiento reducido posterior al impacto.
\end{enumerate}

La magnitud de aceleración total se calcula mediante la fórmula:

\begin{equation}
|a| = \sqrt{a_x^2 + a_y^2 + a_z^2}
\label{eq:magnitud}
\end{equation}

Donde $a_x$, $a_y$ y $a_z$ representan las componentes de aceleración en cada eje del espacio tridimensional.

\subsection{Arquitectura de Aplicaciones Web Modernas}

\subsubsection{Next.js}

Next.js es un framework de React desarrollado por Vercel que permite la creación de aplicaciones web con renderizado del lado del servidor (SSR) y generación de sitios estáticos (SSG). Sus características principales incluyen:

\begin{itemize}[leftmargin=2cm]
    \item Enrutamiento basado en sistema de archivos
    \item API Routes para crear endpoints backend
    \item Optimización automática de imágenes
    \item Soporte para TypeScript
    \item Despliegue simplificado en Vercel
\end{itemize}

\subsubsection{Supabase}

Supabase es una plataforma de base de datos como servicio (DBaaS) de código abierto que proporciona:

\begin{itemize}[leftmargin=2cm]
    \item Base de datos PostgreSQL administrada
    \item API RESTful automática
    \item Autenticación integrada
    \item Almacenamiento de archivos
    \item Funciones serverless
\end{itemize}

\newpage

% ============================================================================
% 3. MATERIALES Y MÉTODOS
% ============================================================================
\section{Materiales y Métodos}

\subsection{Materiales}

\subsubsection{Componentes de Hardware}

\begin{table}[H]
\centering
\caption{Lista de materiales de hardware utilizados}
\label{tab:materiales}
\begin{tabular}{llcc}
\toprule
\textbf{Componente} & \textbf{Descripción} & \textbf{Cantidad} & \textbf{Costo (S/)} \\
\midrule
ESP32-CAM & Microcontrolador con WiFi & 1 & 35.00 \\
MPU6050 & Sensor acelerómetro/giroscopio & 1 & 15.00 \\
Protoboard & Placa de pruebas 830 puntos & 1 & 12.00 \\
Fuente 5V & Adaptador de corriente 5V 2A & 1 & 15.00 \\
Cables Dupont & Cables de conexión M-M, M-H & 20 & 5.00 \\
Buzzer/Bocina & Indicador audible & 1 & 3.00 \\
Cable USB & Programación ESP32 & 1 & 10.00 \\
\midrule
\multicolumn{3}{r}{\textbf{Total}} & \textbf{95.00} \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Software y Servicios}

\begin{itemize}[leftmargin=2cm]
    \item \textbf{Arduino IDE 2.x:} Entorno de desarrollo para programación del ESP32.
    \item \textbf{Visual Studio Code:} Editor de código para desarrollo web.
    \item \textbf{Node.js v18+:} Entorno de ejecución JavaScript.
    \item \textbf{Git:} Control de versiones.
    \item \textbf{Vercel:} Plataforma de despliegue para aplicaciones web.
    \item \textbf{Supabase:} Base de datos PostgreSQL en la nube.
    \item \textbf{GitHub:} Repositorio de código fuente.
\end{itemize}

\subsection{Metodología de Desarrollo}

El proyecto siguió una metodología ágil con iteraciones incrementales, organizadas en las siguientes fases:

\begin{enumerate}[leftmargin=2cm]
    \item \textbf{Fase de análisis:} Definición de requisitos y arquitectura del sistema.
    \item \textbf{Fase de diseño:} Diseño de circuitos, base de datos y arquitectura de software.
    \item \textbf{Fase de implementación:} Desarrollo del firmware y aplicación web.
    \item \textbf{Fase de integración:} Conexión de todos los componentes del sistema.
    \item \textbf{Fase de pruebas:} Validación del funcionamiento del sistema.
\end{enumerate}

\subsection{Arquitectura del Sistema}

El sistema implementa una arquitectura IoT de tres capas, como se ilustra a continuación:

\begin{verbatim}
+-------------------+      WiFi       +------------------+
|   ESP32-CAM       |  ------------> |    Vercel        |
|   + MPU6050       |    HTTP POST   |   (API + Web)    |
+-------------------+                 +------------------+
                                              |
                                              | SQL
                                              v
                                      +------------------+
                                      |    Supabase      |
                                      |   (PostgreSQL)   |
                                      +------------------+
\end{verbatim}

\subsubsection{Capa de Percepción (Edge)}

Esta capa comprende el hardware embebido:
\begin{itemize}[leftmargin=2cm]
    \item ESP32-CAM como unidad de procesamiento y comunicación
    \item MPU6050 como sensor de movimiento
    \item Comunicación I2C entre ESP32 y sensor
\end{itemize}

\subsubsection{Capa de Red}

La comunicación se realiza mediante:
\begin{itemize}[leftmargin=2cm]
    \item WiFi 802.11 b/g/n para conectividad a Internet
    \item Protocolo HTTPS para transmisión segura de datos
    \item API RESTful con formato JSON
\end{itemize}

\subsubsection{Capa de Aplicación}

Implementada en la nube con:
\begin{itemize}[leftmargin=2cm]
    \item Next.js 14 con App Router para la aplicación web
    \item API Routes para endpoints de recepción de datos
    \item React para la interfaz de usuario
    \item Supabase para almacenamiento persistente
\end{itemize}

\newpage

% ============================================================================
% 4. DESARROLLO DEL PROYECTO
% ============================================================================
\section{Desarrollo del Proyecto}

\subsection{Diagrama de Conexiones}

Las conexiones entre el ESP32-CAM y el sensor MPU6050 se realizan mediante el protocolo I2C:

\begin{table}[H]
\centering
\caption{Conexiones ESP32-CAM a MPU6050}
\label{tab:conexiones}
\begin{tabular}{ll}
\toprule
\textbf{ESP32-CAM} & \textbf{MPU6050} \\
\midrule
5V & VCC \\
GND & GND \\
GPIO14 & SDA \\
GPIO15 & SCL \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Nota importante:} Las conexiones deben realizarse con el ESP32-CAM separado de la base USB programadora para evitar conflictos con los pines I2C.

\subsection{Firmware del ESP32}

El firmware implementa las siguientes funcionalidades:

\subsubsection{Inicialización del Sistema}

\begin{lstlisting}[language=C++, caption={Configuración inicial del sistema}]
#include <WiFi.h>
#include <HTTPClient.h>
#include <Wire.h>
#include <MPU6050.h>

// Configuracion WiFi
const char* ssid = "NOMBRE_RED";
const char* password = "CONTRASENA";

// URLs del servidor
const char* serverUrl = "https://iot-nu-nine.vercel.app/api/fall-detection";
const char* statusUrl = "https://iot-nu-nine.vercel.app/api/status";

// Pines I2C para ESP32-CAM
#define SDA_PIN 14
#define SCL_PIN 15

// Sensor
MPU6050 mpu;

// Umbrales de deteccion
const float CAIDA_LIBRE = 0.5;  // Menos de 0.5G = caida libre
const float IMPACTO = 2.5;      // Mas de 2.5G = impacto
\end{lstlisting}

\subsubsection{Algoritmo de Detección}

El algoritmo implementa un sistema de dos fases para la detección de caídas:

\begin{lstlisting}[language=C++, caption={Algoritmo de detección de caídas}]
void loop() {
  // Leer sensor
  int16_t ax, ay, az, gx, gy, gz;
  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

  // Convertir a G (escala +/- 2G)
  float accelX = ax / 16384.0;
  float accelY = ay / 16384.0;
  float accelZ = az / 16384.0;

  // Calcular magnitud total
  float magnitud = sqrt(accelX*accelX + accelY*accelY + accelZ*accelZ);

  // Detectar caida libre
  if (magnitud < CAIDA_LIBRE && !posibleCaida) {
    posibleCaida = true;
    tiempoCaida = millis();
  }

  // Detectar impacto despues de caida libre
  if (posibleCaida && magnitud > IMPACTO) {
    enviarAlerta(magnitud);
    posibleCaida = false;
  }

  // Timeout de 2 segundos
  if (posibleCaida && (millis() - tiempoCaida > 2000)) {
    posibleCaida = false;
  }

  delay(100);  // Muestreo a 10 Hz
}
\end{lstlisting}

\subsubsection{Comunicación HTTP}

\begin{lstlisting}[language=C++, caption={Envío de alertas al servidor}]
void enviarAlerta(float magnitud) {
  if (WiFi.status() != WL_CONNECTED) {
    WiFi.reconnect();
    delay(5000);
    if (WiFi.status() != WL_CONNECTED) return;
  }

  HTTPClient http;
  http.begin(serverUrl);
  http.addHeader("Content-Type", "application/json");

  // Crear JSON
  String jsonData = "{";
  jsonData += "\"evento\":\"caida\",";
  jsonData += "\"magnitud\":" + String(magnitud, 2) + ",";
  jsonData += "\"dispositivo\":\"" + String(deviceId) + "\"";
  jsonData += "}";

  int httpCode = http.POST(jsonData);

  if (httpCode > 0) {
    String response = http.getString();
    Serial.println("Respuesta: " + response);
  }

  http.end();
}
\end{lstlisting}

\subsection{Backend - API REST}

El backend se implementó utilizando Next.js 14 con API Routes, proporcionando tres endpoints principales:

\subsubsection{Endpoint de Detección de Caídas}

\begin{lstlisting}[language=JavaScript, caption={API de detección de caídas (fall-detection/route.ts)}]
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

export async function POST(request: NextRequest) {
  try {
    const data = await request.json()

    const supabase = createClient(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_ANON_KEY!
    )

    const { data: event, error } = await supabase
      .from('events')
      .insert({
        tipo: data.evento || 'caida',
        magnitud: data.magnitud || 0,
        dispositivo: data.dispositivo || 'ESP32-CAM'
      })
      .select()
      .single()

    if (error) {
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 500 }
      )
    }

    return NextResponse.json({
      success: true,
      message: 'Alerta recibida',
      eventId: event.id
    })
  } catch (error) {
    return NextResponse.json(
      { success: false, error: 'Error procesando alerta' },
      { status: 500 }
    )
  }
}
\end{lstlisting}

\subsubsection{Endpoint de Estado del Dispositivo}

\begin{lstlisting}[language=JavaScript, caption={API de estado (status/route.ts)}]
let lastPing = 0
let deviceInfo: any = null

export async function GET() {
  const now = Date.now()
  const isOnline = (now - lastPing) < 30000

  return NextResponse.json({
    online: isOnline,
    lastUpdate: lastPing
      ? new Date(lastPing).toLocaleString('es-PE')
      : null,
    device: deviceInfo
  })
}

export async function POST(request: NextRequest) {
  const data = await request.json()
  lastPing = Date.now()
  deviceInfo = {
    id: data.dispositivo,
    ip: data.ip,
    rssi: data.rssi
  }
  return NextResponse.json({ success: true })
}
\end{lstlisting}

\subsubsection{Endpoint de Eventos}

\begin{lstlisting}[language=JavaScript, caption={API de eventos (events/route.ts)}]
export async function GET() {
  const supabase = createClient(
    process.env.SUPABASE_URL!,
    process.env.SUPABASE_ANON_KEY!
  )

  const { data: events, error } = await supabase
    .from('events')
    .select('*')
    .order('fecha', { ascending: false })
    .limit(50)

  return NextResponse.json({
    success: true,
    events: events || [],
    total: events?.length || 0
  })
}
\end{lstlisting}

\subsection{Frontend - Dashboard Web}

El dashboard se desarrolló utilizando React con componentes funcionales y hooks para el manejo del estado.

\subsubsection{Estructura de la Interfaz}

La interfaz del dashboard incluye:

\begin{enumerate}[leftmargin=2cm]
    \item \textbf{Header:} Navegación y estado de conexión del dispositivo
    \item \textbf{Tarjetas de estadísticas:} Contadores de caídas, pruebas y total de eventos
    \item \textbf{Panel de estado:} Información del dispositivo y botón de prueba
    \item \textbf{Historial de eventos:} Lista cronológica de todos los eventos registrados
\end{enumerate}

\subsubsection{Actualización en Tiempo Real}

\begin{lstlisting}[language=JavaScript, caption={Hook de actualización automática}]
useEffect(() => {
  fetchEvents()
  fetchStatus()

  // Actualizar cada 5 segundos
  const interval = setInterval(() => {
    fetchEvents()
    fetchStatus()
  }, 5000)

  return () => clearInterval(interval)
}, [])
\end{lstlisting}

\subsection{Base de Datos}

La estructura de la base de datos en Supabase consiste en una tabla principal para el registro de eventos:

\begin{lstlisting}[language=SQL, caption={Esquema de la tabla events}]
CREATE TABLE events (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  tipo VARCHAR(50) NOT NULL,
  magnitud DECIMAL(5,2) NOT NULL,
  dispositivo VARCHAR(100) NOT NULL,
  fecha TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indice para consultas por fecha
CREATE INDEX idx_events_fecha ON events(fecha DESC);
\end{lstlisting}

\subsection{Repositorio y Control de Versiones}

El proyecto se gestiona mediante Git con el siguiente historial de commits principales:

\begin{table}[H]
\centering
\caption{Historial de versiones del proyecto}
\label{tab:commits}
\begin{tabular}{lp{10cm}}
\toprule
\textbf{Commit} & \textbf{Descripción} \\
\midrule
aca52fd & Mejoras de UI: dashboard con estadísticas, iconos y animaciones \\
786205f & Limpieza de API de eventos - remover código de debug \\
9a7eae4 & Fix: Lazy load del cliente Supabase \\
dd13f9c & Integración de Supabase para persistencia de eventos \\
31b1a0e & Rediseño minimalista completo de la interfaz \\
ee2c024 & Sistema completo de detección de caídas IoT \\
\bottomrule
\end{tabular}
\end{table}

\textbf{URL del Repositorio:} \url{https://github.com/brolyroly007/iot}

\textbf{URL del Dashboard:} \url{https://iot-nu-nine.vercel.app/dashboard}

\newpage

% ============================================================================
% 5. RESULTADOS
% ============================================================================
\section{Resultados}

\subsection{Funcionamiento del Sistema}

El sistema implementado logró los siguientes resultados:

\subsubsection{Detección de Caídas}

El algoritmo de detección demostró ser efectivo en la identificación de patrones de caída mediante:

\begin{itemize}[leftmargin=2cm]
    \item Detección de fase de caída libre cuando $|a| < 0.5G$
    \item Detección de impacto cuando $|a| > 2.5G$
    \item Ventana temporal de 2 segundos para correlación de eventos
    \item Frecuencia de muestreo de 10 Hz (cada 100 ms)
\end{itemize}

\subsubsection{Comunicación y Latencia}

\begin{table}[H]
\centering
\caption{Métricas de comunicación del sistema}
\label{tab:metricas}
\begin{tabular}{ll}
\toprule
\textbf{Métrica} & \textbf{Valor} \\
\midrule
Latencia promedio de transmisión & 200-500 ms \\
Intervalo de ping (heartbeat) & 10 segundos \\
Timeout de conexión & 30 segundos \\
Actualización del dashboard & 5 segundos \\
Tasa de éxito de transmisión & $>$ 95\% \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Interfaz de Usuario}

El dashboard web presenta las siguientes características funcionales:

\begin{enumerate}[leftmargin=2cm]
    \item Indicador visual de estado del dispositivo (online/offline)
    \item Contador de eventos por tipo (caídas reales vs pruebas)
    \item Historial cronológico con formato de tiempo relativo
    \item Botón de prueba para verificación del sistema
    \item Diseño responsivo adaptable a dispositivos móviles
\end{enumerate}

\subsection{Consumo de Recursos}

\begin{table}[H]
\centering
\caption{Consumo de recursos del ESP32}
\label{tab:consumo}
\begin{tabular}{ll}
\toprule
\textbf{Recurso} & \textbf{Uso} \\
\midrule
Memoria Flash (programa) & 45\% \\
RAM (variables) & 15\% \\
Consumo de corriente (WiFi activo) & ~160 mA \\
Consumo de corriente (transmisión) & ~240 mA \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Validación del Sistema}

Se realizaron pruebas controladas para validar el funcionamiento:

\begin{enumerate}[leftmargin=2cm]
    \item \textbf{Prueba de caída simulada:} Se dejó caer el dispositivo desde 1 metro de altura sobre una superficie acolchada. Resultado: Detección exitosa en 9 de 10 intentos.
    \item \textbf{Prueba de falsos positivos:} Se realizaron movimientos bruscos sin patrón de caída. Resultado: 0 falsos positivos en 20 pruebas.
    \item \textbf{Prueba de conectividad:} Se monitoreó la estabilidad de conexión durante 24 horas. Resultado: 99.2\% de disponibilidad.
\end{enumerate}

\newpage

% ============================================================================
% 6. CONCLUSIONES
% ============================================================================
\section{Conclusiones}

\subsection{Conclusiones Generales}

\begin{enumerate}[leftmargin=2cm]
    \item Se logró implementar exitosamente un sistema IoT de detección de caídas utilizando componentes de bajo costo (ESP32-CAM y MPU6050), con un costo total de hardware inferior a S/ 100.00.

    \item El algoritmo de detección basado en análisis de magnitud de aceleración demostró ser efectivo para identificar patrones de caída, con umbrales configurables que permiten ajustar la sensibilidad del sistema.

    \item La arquitectura serverless implementada con Vercel y Supabase proporciona una solución escalable y de alta disponibilidad sin costos de infraestructura inicial.

    \item El dashboard web desarrollado con Next.js 14 y React ofrece una interfaz intuitiva para el monitoreo en tiempo real, con actualizaciones automáticas cada 5 segundos.

    \item La integración completa del sistema demuestra la viabilidad de desarrollar soluciones IoT para el cuidado de adultos mayores utilizando tecnologías open source y servicios cloud gratuitos.
\end{enumerate}

\subsection{Recomendaciones}

\begin{enumerate}[leftmargin=2cm]
    \item Implementar notificaciones push mediante servicios como Twilio (WhatsApp) o Resend (Email) para alertar a familiares y cuidadores.

    \item Agregar un módulo de cámara para captura de evidencia visual al momento de detectar una caída.

    \item Implementar algoritmos de machine learning para mejorar la precisión de detección y reducir falsos positivos.

    \item Diseñar una carcasa ergonómica tipo pulsera o collar para facilitar el uso por parte de adultos mayores.

    \item Implementar modo de bajo consumo con wake-up por interrupción del sensor para extender la vida de batería.
\end{enumerate}

\subsection{Trabajos Futuros}

\begin{itemize}[leftmargin=2cm]
    \item Integración con servicios de emergencia (bomberos, ambulancias)
    \item Aplicación móvil complementaria para familiares
    \item Soporte para múltiples dispositivos por usuario
    \item Análisis predictivo basado en patrones de movimiento
    \item Integración con sistemas de domótica del hogar
\end{itemize}

\newpage

% ============================================================================
% 7. REFERENCIAS BIBLIOGRÁFICAS
% ============================================================================
\section{Referencias Bibliográficas}

\begin{enumerate}[leftmargin=2cm]
    \item Ashton, K. (2009). That 'Internet of Things' thing. \textit{RFID Journal}, 22(7), 97-114.

    \item Bourke, A. K., O'Brien, J. V., \& Lyons, G. M. (2007). Evaluation of a threshold-based tri-axial accelerometer fall detection algorithm. \textit{Gait \& Posture}, 26(2), 194-199. \url{https://doi.org/10.1016/j.gaitpost.2006.09.012}

    \item Espressif Systems. (2023). \textit{ESP32 Technical Reference Manual}. Espressif. \url{https://www.espressif.com/sites/default/files/documentation/esp32_technical_reference_manual_en.pdf}

    \item InvenSense. (2013). \textit{MPU-6000 and MPU-6050 Product Specification Revision 3.4}. TDK InvenSense. \url{https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf}

    \item Next.js Documentation. (2024). \textit{Next.js 14 Documentation}. Vercel. \url{https://nextjs.org/docs}

    \item Organización Mundial de la Salud. (2021). \textit{Caídas}. OMS. \url{https://www.who.int/es/news-room/fact-sheets/detail/falls}

    \item Supabase Documentation. (2024). \textit{Supabase Docs}. Supabase. \url{https://supabase.com/docs}

    \item Vercel Documentation. (2024). \textit{Vercel Platform Documentation}. Vercel. \url{https://vercel.com/docs}

    \item World Health Organization. (2007). \textit{WHO Global Report on Falls Prevention in Older Age}. WHO Press.
\end{enumerate}

\newpage

% ============================================================================
% 8. ANEXOS
% ============================================================================
\section{Anexos}

\subsection{Anexo A: Código Completo del Firmware ESP32}

\begin{lstlisting}[language=C++, caption={detector\_caidas.ino - Código completo del firmware}]
/*
 * DETECTOR DE CAIDAS - ESP32-CAM + MPU6050
 * URL Dashboard: https://iot-nu-nine.vercel.app/dashboard
 *
 * Conexiones:
 * ESP32-CAM  ->  MPU6050
 * 5V         ->  VCC
 * GND        ->  GND
 * GPIO14     ->  SDA
 * GPIO15     ->  SCL
 */

#include <WiFi.h>
#include <HTTPClient.h>
#include <Wire.h>
#include <MPU6050.h>

// CONFIGURACION WIFI
const char* ssid = "NOMBRE_RED_WIFI";
const char* password = "CONTRASENA_WIFI";

// URL DE TU SERVIDOR EN VERCEL
const char* serverUrl = "https://iot-nu-nine.vercel.app/api/fall-detection";
const char* statusUrl = "https://iot-nu-nine.vercel.app/api/status";

// ID del dispositivo
const char* deviceId = "ESP32-CAM-001";

// Pines I2C para ESP32-CAM
#define SDA_PIN 14
#define SCL_PIN 15

// Sensor
MPU6050 mpu;

// Umbrales de deteccion
const float CAIDA_LIBRE = 0.5;
const float IMPACTO = 2.5;

// Variables de estado
bool posibleCaida = false;
unsigned long tiempoCaida = 0;
unsigned long ultimoPing = 0;
const unsigned long INTERVALO_PING = 10000;

void setup() {
  Serial.begin(115200);
  delay(1000);

  Serial.println("========================================");
  Serial.println("   DETECTOR DE CAIDAS - ESP32-CAM");
  Serial.println("========================================");

  // Iniciar I2C
  Wire.begin(SDA_PIN, SCL_PIN);

  // Iniciar MPU6050
  Serial.print("[MPU6050] Iniciando... ");
  mpu.initialize();

  if (mpu.testConnection()) {
    Serial.println("OK!");
  } else {
    Serial.println("ERROR!");
    Serial.println("[MPU6050] Verifica las conexiones");
  }

  // Conectar WiFi
  Serial.print("[WiFi] Conectando a: ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  int intentos = 0;
  while (WiFi.status() != WL_CONNECTED && intentos < 30) {
    delay(500);
    Serial.print(".");
    intentos++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n[WiFi] CONECTADO!");
    Serial.print("[WiFi] IP: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\n[WiFi] ERROR: No se pudo conectar");
  }

  Serial.println("[Sistema] Monitoreando caidas...");
}

void loop() {
  int16_t ax, ay, az, gx, gy, gz;
  mpu.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

  float accelX = ax / 16384.0;
  float accelY = ay / 16384.0;
  float accelZ = az / 16384.0;

  float magnitud = sqrt(accelX*accelX + accelY*accelY + accelZ*accelZ);

  Serial.print("[Sensor] Magnitud: ");
  Serial.print(magnitud, 2);
  Serial.print(" G");

  if (magnitud < CAIDA_LIBRE && !posibleCaida) {
    posibleCaida = true;
    tiempoCaida = millis();
    Serial.print(" >>> CAIDA LIBRE!");
  }

  if (posibleCaida && magnitud > IMPACTO) {
    Serial.println("\n!!! CAIDA DETECTADA !!!");
    enviarAlerta(magnitud);
    posibleCaida = false;
  }

  if (posibleCaida && (millis() - tiempoCaida > 2000)) {
    posibleCaida = false;
  }

  Serial.println();

  if (millis() - ultimoPing > INTERVALO_PING) {
    enviarPing();
    ultimoPing = millis();
  }

  delay(100);
}

void enviarAlerta(float magnitud) {
  if (WiFi.status() != WL_CONNECTED) {
    WiFi.reconnect();
    delay(5000);
    if (WiFi.status() != WL_CONNECTED) return;
  }

  HTTPClient http;
  http.begin(serverUrl);
  http.addHeader("Content-Type", "application/json");

  String jsonData = "{";
  jsonData += "\"evento\":\"caida\",";
  jsonData += "\"magnitud\":" + String(magnitud, 2) + ",";
  jsonData += "\"dispositivo\":\"" + String(deviceId) + "\"";
  jsonData += "}";

  int httpCode = http.POST(jsonData);

  if (httpCode > 0) {
    Serial.println("[HTTP] Alerta enviada OK");
  } else {
    Serial.println("[HTTP] Error enviando alerta");
  }

  http.end();
}

void enviarPing() {
  if (WiFi.status() != WL_CONNECTED) return;

  HTTPClient http;
  http.begin(statusUrl);
  http.addHeader("Content-Type", "application/json");

  String jsonData = "{";
  jsonData += "\"dispositivo\":\"" + String(deviceId) + "\",";
  jsonData += "\"ip\":\"" + WiFi.localIP().toString() + "\",";
  jsonData += "\"rssi\":" + String(WiFi.RSSI());
  jsonData += "}";

  int httpCode = http.POST(jsonData);
  if (httpCode > 0) Serial.println("[Ping] OK");

  http.end();
}
\end{lstlisting}

\subsection{Anexo B: Estructura del Proyecto Web}

\begin{verbatim}
iot/
├── app/
│   ├── api/
│   │   ├── events/
│   │   │   └── route.ts
│   │   ├── fall-detection/
│   │   │   └── route.ts
│   │   └── status/
│   │       └── route.ts
│   ├── dashboard/
│   │   └── page.tsx
│   ├── globals.css
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── .env.example
├── next.config.js
├── package.json
├── tailwind.config.ts
├── tsconfig.json
└── README.md
\end{verbatim}

\subsection{Anexo C: Variables de Entorno}

\begin{lstlisting}[caption={Archivo .env.example}]
# TWILIO (WhatsApp)
TWILIO_ACCOUNT_SID=tu_account_sid
TWILIO_AUTH_TOKEN=tu_auth_token
TWILIO_WHATSAPP_FROM=+14155238886
WHATSAPP_PHONE_1=+51987654321

# RESEND (Email)
RESEND_API_KEY=re_xxxxxxxxxxxx
RESEND_FROM=onboarding@resend.dev
EMAIL_1=familiar1@email.com

# SUPABASE
SUPABASE_URL=https://xxxx.supabase.co
SUPABASE_ANON_KEY=tu_anon_key
\end{lstlisting}

\subsection{Anexo D: Dependencias del Proyecto}

\begin{lstlisting}[language=JSON, caption={package.json - Dependencias}]
{
  "name": "detector-caidas",
  "version": "2.0.0",
  "dependencies": {
    "next": "14.2.21",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "@supabase/supabase-js": "^2.47.10",
    "resend": "^4.0.1",
    "twilio": "^5.4.0",
    "lucide-react": "^0.468.0",
    "clsx": "^2.1.1",
    "tailwind-merge": "^2.6.0"
  },
  "devDependencies": {
    "typescript": "^5.7.2",
    "@types/node": "^22.10.2",
    "@types/react": "^18.3.17",
    "tailwindcss": "^3.4.17"
  }
}
\end{lstlisting}

\end{document}
